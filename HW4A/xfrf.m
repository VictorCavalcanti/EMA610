function [f,g,t,h]=xfrf(a,b,c,d)%%   Created by:     Daniel C. Kammer%                   Assistant Professor%                   Dept of Engineering Mechanics%                   University of Wisconsin%                   Madison, WI  53706%                   (608) 262-5724 / 262-3990%%  Predicts the frequency response function matrix using correlation%  DFT and averaging%%  %  HISTORY%  =======%%   Created 09-01-94%   ----------------%%%  Use:  [f,g,t,h]=xfrf(a,b,c,d);%%  INPUT%  =====%  a      = plant matrix%  b      = input influence matrix%  c      = output influence matrix%  d      = direct feedthrough matrix%%  OUTPUT%  ======%  f      = frequencies in Hertz%  g      = discrete frequency response function matrix [ns x (naxnt)]%  t      = time vector%  h      = pulse response matrix [ns x (naxnt)]%==================================================================%Date=date;%%  Input time step%  ---------------dt = input('Time Step = ');%%  Input number of data points%  ---------------------------nt = input('Number of Data Points = ');%%  Input number of averages%  ------------------------nave = input('Number of Averages = ');%%  Input noise level%  -----------------nl = input('Noise Level (%) = ');%[ns,m]=size(c);                    % number of sensors[m,na]=size(b);                    % number of inputs%t1=clock;                          % start clock%t=[0:dt:(nt-1)*dt]';               % time vectorf=inv(dt)*(0:nt-1)'/nt;            % frequency vector in Hertz%%  Build frequency response function matrix%  ----------------------------------------ia=(1:na)';                        % input counteris=(1:ns)';                        % output counterPxy=zeros(ns,nt*na);Pxx=zeros(na,nt*na);%for i = 1:nave                     % loop over tests  u=[zeros(1,na);10*randn((nt/2-1),na);zeros(nt/2,na)];  y=lsim(a,b,c,d,u,t);             % response  rms=sqrt((sum(y(:,1).^2))/nt);   % rms value  y=y+((nl/100)*rms*randn(nt,ns)); % add noise  plot(y(:,1))  uf=fft(u);                       % DFT of input  yf=fft(y);                       % DFT of output  uf=uf.';  yf=yf.';%  for j=1:nt                       % loop over data points    xy=yf(:,j)*uf(:,j)';           % cross spectral density at j	xx=uf(:,j)*uf(:,j)';           % spectral desity at j	pxy(:,(j-1)*na+ia)=xy;         % build csd matrix	pxx(:,(j-1)*na+ia)=xx;         % build sd matrix  end%  Pxy=Pxy+pxy;                     % cross spectral density  Pxx=Pxx+pxx;                     % spectral densityend%for j=1:nt                         % loop over data points  g(:,(j-1)*na+ia)=Pxy(:,(j-1)*na+ia)*...  inv(Pxx(:,(j-1)*na+ia));         % build frf matrixend%%  Generate pulse response%  -----------------------for i=1:ns                         % loop over sensors%  for j=1:na                       % loop over inputs%  ic=(j:na:(na*nt))';              % column index vector  q=g(i,ic);                       % frf for ith sensor and jth input  q=(real(ifft(q.')))';            % take inverse fft and transpose  h(i,ic)=q;                       % build pulse response matrix  end%end%t2=clock;Etime=etime(t2,t1);                 % clock time duration%end